You are an expert full-stack developer specializing in Next.js, Prisma, and Node.js. Your task is to build a full-stack web app called "TitleTesterPro" from the ground up.

Follow these instructions precisely.

1. Project Goal & Tech Stack:

Goal: A web app for YouTubers to A/B test video titles automatically.
Primary Tech Stack:
Framework: Next.js 14+ (App Router) with TypeScript
Database ORM: Prisma
Database: PostgreSQL
Styling: Tailwind CSS
Charts: Recharts
Authentication: next-auth v5 (Auth.js)
Scheduler: agenda
2. Initial Setup:

Initialize a new Next.js project with TypeScript and Tailwind CSS.
Initialize Prisma with the PostgreSQL provider.
3. Database Schema (prisma/schema.prisma):
Create this exact schema. This is the single source of truth for our data.

Code snippet

// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  image         String?
  youtubeId     String?   @unique
  oauthToken    String?   // Encrypted
  refreshToken  String?   // Encrypted
  tests         Test[]
  createdAt     DateTime  @default(now())

  accounts      Account[]
  sessions      Session[]
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}


model Test {
  id                      String    @id @default(cuid())
  user                    User      @relation(fields: [userId], references: [id])
  userId                  String
  videoId                 String
  rotationIntervalMinutes Int
  status                  String    @default("pending") // "pending", "active", "paused", "completed"
  winnerMetric            String    @default("ctr") // "ctr", "avd"
  createdAt               DateTime  @default(now())

  titles                  Title[]
}

model Title {
  id              String           @id @default(cuid())
  test            Test             @relation(fields: [testId], references: [id], onDelete: Cascade)
  testId          String
  text            String
  order           Int              // Rotation order (0, 1, 2...)
  activatedAt     DateTime?

  analyticsPolls  AnalyticsPoll[]
  summary         TitleSummary?
}

model AnalyticsPoll {
  id                   String   @id @default(cuid())
  title                Title    @relation(fields: [titleId], references: [id], onDelete: Cascade)
  titleId              String
  polledAt             DateTime @default(now())
  views                Int
  impressions          Int
  ctr                  Float
  averageViewDuration  Int      // Seconds
}

model TitleSummary {
  id                String   @id @default(cuid())
  title             Title    @relation(fields: [titleId], references: [id], onDelete: Cascade)
  titleId           String   @unique
  totalViews        Int
  totalImpressions  Int
  finalCtr          Float
  finalAvd          Int      // Average View Duration
  completedAt       DateTime @default(now())
}
4. Authentication (lib/auth.ts and API route):

Set up next-auth with the Google Provider.
Request the https://www.googleapis.com/auth/youtube.force-ssl scope.
In the callbacks, persist the access_token and refresh_token to our Account model. It is critical that you show how to encrypt these tokens before saving them.
5. Core API Endpoints (Next.js API Routes):

app/api/tests/create/route.ts (POST):

Protected route; requires authentication.
Expects videoId, titles (an array of strings), and rotationIntervalMinutes.
Creates a Test record and associated Title records in the database.
Schedules the initial job with Agenda: agenda.schedule('in 1 minute', 'rotateTitle', { testId: newTest.id, titleOrder: 0 });.
Returns the new Test object.
app/api/tests/[testId]/status/route.ts (PUT):

Protected route.
Expects a status in the body ("paused" or "active").
Updates the status of the specified Test. This is for the Pause/Resume toggle.
6. Background Worker (jobs/scheduler.ts):
This script will be run as a separate process (node jobs/scheduler.ts).

Setup: Initialize Agenda to connect to a database (e.g., MongoDB, or manage state in Postgres).

Job 1: rotateTitle

Input: { testId, titleOrder }.
Logic:
Fetch the test from the database. If status is "paused" or "completed", stop.
If titleOrder > 0, find the previous title, aggregate all its AnalyticsPoll data, and create a TitleSummary record.
Find the Title record where order === titleOrder.
If no title is found, the test is over. Update the Test status to "completed" and exit.
If a title is found:
Call the YouTube Data API to update the video title.
Update the Title record with activatedAt = new Date().
Schedule the next rotation: agenda.schedule(nextRotationTime, 'rotateTitle', { testId, titleOrder: titleOrder + 1 });.
Schedule the first analytics poll for this title: agenda.schedule('in 15 minutes', 'pollAnalytics', { titleId: newTitle.id });.
Job 2: pollAnalytics

Input: { titleId }.
Logic:
Fetch the title and its parent test. If the test is paused, reschedule this job for 15 minutes later and exit.
Call the YouTube Analytics API to get views, impressions, CTR, and AVD for the video since the activatedAt timestamp.
Create a new AnalyticsPoll record with the fetched data.
Check if the title's active period (rotationIntervalMinutes) is over. If not, reschedule this same job: agenda.schedule('in 15 minutes', 'pollAnalytics', { titleId });.
7. Frontend Components (React/TypeScript):

app/dashboard/page.tsx:

The main dashboard view.
Fetches all tests for the logged-in user.
Displays a list of tests and a form to create a new test.
When a test is selected, it displays the ResultsDashboard component.
components/ResultsDashboard.tsx:

Takes a test object as a prop.
Displays a "Pause/Resume" button that calls the status update API.
Displays an "Export to CSV" button.
Renders the ResultsTable and the CtrBarChart components below.
components/ResultsTable.tsx:

Takes an array of TitleSummary objects as props.
Renders a <table> with columns: Title, Views, CTR, AVD, Impressions.
Highlights the row that is the "winner" based on the winnerMetric from the parent Test object.
components/charts/CtrBarChart.tsx:

Uses Recharts.
Takes an array of TitleSummary objects.
Renders a <BarChart> comparing the finalCtr of each tested title.
8. Final Touches:

Create a .env.example file listing all required environment variables: DATABASE_URL, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, NEXTAUTH_SECRET, NEXTAUTH_URL, ENCRYPTION_KEY, and AGENDA_MONGO_URL (or equivalent).
Add a basic README.md explaining how to set up the project and run both the Next.js app and the scheduler.